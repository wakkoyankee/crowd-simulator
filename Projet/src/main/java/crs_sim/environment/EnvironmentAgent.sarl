/** 
 * 
 */
package crs_sim.environment

import crs_sim.^agent.CRS
import crs_sim.^agent.Protestor
import crs_sim.body.CRSBody
import crs_sim.body.Destroyable
import crs_sim.body.EnvObject
import crs_sim.body.MobileObject
import crs_sim.body.ProtestorBody
import crs_sim.ui.Window
import crs_sim.utils.Action
import crs_sim.utils.CRS_Sim_Utils
import crs_sim.utils.GraphSearch_Utils
import crs_sim.utils.ParamSimu
import crs_sim.utils.Types
import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.ParticipantJoined
import io.sarl.core.ParticipantLeft
import io.sarl.core.Schedules
import io.sarl.core.SpaceCreated
import io.sarl.core.SpaceDestroyed
import java.util.ArrayList
import java.util.Queue
import java.util.Random
import java.util.TreeMap
import java.util.UUID
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.atomic.AtomicInteger
import org.arakhne.afc.math.geometry.d2.d.Circle2d
import org.arakhne.afc.math.geometry.d2.d.Point2d
import org.arakhne.afc.math.geometry.d2.d.Rectangle2d
import org.arakhne.afc.math.geometry.d2.d.Shape2d

/** 
 * @author hadrien
 * 
 */
 
 // papyrus
 
agent EnvironmentAgent {
	uses Logging
	uses Lifecycle
	uses DefaultContextInteractions
	uses Schedules
	
	var rootTree : QTNode
	
	var agentSpawned = new AtomicInteger(0)
	var protestorList : TreeMap<UUID, ProtestorBody>
	var crsList : TreeMap<UUID, CRSBody>
	
	var win : Window
	var protestorResp = new AtomicInteger(0)
	var crsResp = new AtomicInteger(0)
	var influenceList : Queue<Influence> = new ConcurrentLinkedQueue<Influence>()
	
	var aggObjs : TreeMap<UUID,Destroyable>
	
	var bodiesDespawned : ArrayList<EnvObject>
	var time : int = 0
	var nbPro = 0
	var nbCrs = 0
	
//	var b = [1,2,3,4,5,6]
//	var c = b[0]
	
	on Initialize {

		info("The agent environment was started.")
	
		// INIT BEHAVIORS, TOLERANCES AND PROTESTORBODY LIST
		this.protestorList = new TreeMap<UUID, ProtestorBody>
		var rand : Random = new Random()
		var b : int[] = newIntArrayOfSize(ParamSimu.nbProtestors) // creer ist de behavior  et tolerance quon donne aux agents
		
		var t : int[] = newIntArrayOfSize(ParamSimu.nbProtestors)
		for (var i = 0; i < ParamSimu.nbProtestors; i++) {
			var r1 =  10 //rand.nextInt(101) 
			var r2 =  rand.nextInt(11)
			b.set(i, r1)
			t.set(i, r2)
			var pb : ProtestorBody
			if (r1 < ParamSimu.maxPanic) {
				pb = new ProtestorBody(ParamSimu.initCollecProtestor.get(i), Types.protestor_panic)
			} else if (r1 > ParamSimu.minAggressive) {
				pb = new ProtestorBody(ParamSimu.initCollecProtestor.get(i), Types.protestor_agg)
			} else {
				pb = new ProtestorBody(ParamSimu.initCollecProtestor.get(i), Types.protestor_neutral)
			}
			
			this.protestorList.put(pb.getUuid(),pb)//Ajout le protestor body cree
		}
		
		// INIT AGG OBJS //
		
		this.aggObjs = new TreeMap<UUID, Destroyable>
		for (destroyable : ParamSimu.aggObjs){
			this.aggObjs.put(destroyable.getUuid(), destroyable)
		}
		

		//// CREATION ENVIRONEMENT  ////
		
		// collec.addAll(ParamSimu.initCollecCRS)
		// collec.addAll(ParamSimu.initCollecProtestor)
		// collec.addAll(ParamSimu.initCollecBuilding)
		var collec = new ArrayList<EnvObject>()
		//collec.addAll(this.protestorList)
		collec.addAll(ParamSimu.initCollecCRS)
		collec.addAll(ParamSimu.initplaceDesJacobins)
		rootTree = new QTNode(
			new Rectangle2d(0, 0, ParamSimu.mapSizeX, ParamSimu.mapSizeY)
		)
		CRS_Sim_Utils.buildTree(rootTree, collec)
		
		
		for (entry : this.protestorList.entrySet()) { // ADD PROTESTORS TO TREE
			rootTree.insert(entry.getValue())
		}

		for (entry : this.aggObjs.entrySet()) { // ADD Destroyables TO TREE
			rootTree.insert(entry.getValue())
		}
		
		this.crsList = new TreeMap<UUID, CRSBody>()
		for(var i = 0; i< ParamSimu.initCollecCRS.length; i++){
			this.crsList.put(ParamSimu.initCollecCRS.get(i).getUuid(), ParamSimu.initCollecCRS.get(i))
		}
		
		this.nbPro = this.protestorList.size()
		this.nbCrs = this.crsList.size()
		
		//		println("Père : " + rootTree)
//		println("NW : " + rootTree.firstChild)
//		println("NE : " + rootTree.secondChild)
//		println("SW : " + rootTree.thirdChild)
//		println("SE : " + rootTree.fourthChild)
//		print(collec.get(5) + " : \n")
//		print(collec.get(5).area)
//		rootTree.moveBodyPasOpti(collec.get(5) as MobileObject, new Point2d(800, 800))
//		print(collec.get(5) + " en 800 800: \n")
//		print(collec.get(5).area)
		
		//print("\nBFS\n")
		//GraphSearch_Utils.BFS(rootTree)
		//print("\nPerceptBFSUnoptimized\n")
		//GraphSearch_Utils.PerceptBFSUnoptimized(rootTree,new Circle2d(350,350,150))
		//print("\nPerceptBFS\n")
		//GraphSearch_Utils.PerceptBFS(rootTree, new Circle2d(350, 350, 150))

//		println("Père : " + rootTree)
//		println("NW : " + rootTree.firstChild)
//		println("NE : " + rootTree.secondChild)
//		println("SW : " + rootTree.thirdChild)
//		println("SE : " + rootTree.fourthChild)
			
		// // INIT UI ////
		this.win = new Window()
		redraw()
		// // SPAWN DES AGENTS  ////
		var cpt : int = 0
		for (entry : this.protestorList.entrySet()) { // CREATE PROTESTOR AGENT
			Protestor.spawnInContextWithID(entry.getKey(), defaultContext, b.get(cpt), t.get(cpt))
			cpt++
		}
		
		for (entry : this.crsList.entrySet()) { // CREATE PROTESTOR AGENT
			CRS.spawnInContextWithID(entry.getKey(), defaultContext)
		}
		GraphSearch_Utils.printGraphDebug(rootTree, false)
	}


	on AgentSpawned {
		// Quand tout les protestors on spawn lance la simu
		var cpt = this.agentSpawned.incrementAndGet()
		if(this.agentSpawned == this.nbPro+this.nbCrs){
			info("All agents have spawned")
			StartSim()
		}
	}

	def StartSim() {

		//// BOUCLE DE SIMULATION ////
	
		// // PERCEPTION ////
		for (entry : this.protestorList.entrySet()) {//PROTESTORS
			var id = entry.getKey()
			var body = entry.getValue().getArea() as Circle2d
			var perceptionZone : Circle2d = new Circle2d(body.getX(), body.getY(), ParamSimu.RadiusPerceptProtestor)
			var percept = GraphSearch_Utils.PerceptBFS(this.rootTree, perceptionZone)
			var obj : Shape2d<?>
			var uuidObj :UUID = null
			if (entry.getValue().getType() != Types.protestor_agg) {
				obj = ParamSimu.neutralObj
			}else{
				//if aggobj in percept -> attack else neutralobj
				//get closest aggobj
				obj = this.aggObjs.firstEntry().getValue().getArea()
				uuidObj = this.aggObjs.firstKey()
			}
			emit(new PerceptionEvent(body as Shape2d<?>, percept, obj, uuidObj, 0))[it.UUID == id]
		}
		
		for (entry : this.crsList.entrySet()) {//CRS
			var id = entry.getKey()
			var body = entry.getValue().getArea() as Circle2d
			var perceptionZone : Circle2d = new Circle2d(body.getX(), body.getY(), ParamSimu.RadiusPerceptCrs)
			var percept = GraphSearch_Utils.PerceptBFS(this.rootTree, perceptionZone)
			emit(new PerceptionEvent(body as Shape2d<?>, percept, 0))[it.UUID == id]
		}
		
		
	}
	
	def redraw() {

		// Test UI //
		// Rectangle2d(0, 0, ParamSimu.mapSizeX, ParamSimu.mapSizeY)
		this.win.update(GraphSearch_Utils.BFS(this.rootTree))
		
		//Iterer dans l'abre recup tout les elements avec getPercept et envoyer 
	}


	on InfluenceEvent { // reponse des agents
		var cpt : int
		
		this.influenceList.add(occurrence.influence)
		
		if (occurrence.influence.isProtestor()) {
			cpt = this.protestorResp.incrementAndGet() + this.crsResp.get()
		}else{
			cpt = this.crsResp.incrementAndGet() + this.protestorResp.get()
		}
		
		if (cpt == this.nbPro + this.nbCrs) { // si tout les protestors on donné leur influence
			this.protestorResp.set(0)
			
				//resolveinf
			
			for (influence : this.influenceList) {
				var action : Action = influence.getAction()

				if (action == Action.move) {//Movement
					var body : MobileObject
					if(influence.isProtestor()){
						body = this.protestorList.get(influence.getUuid()) as ProtestorBody
					} else {
						body = this.crsList.get(influence.getUuid()) as CRSBody
					}
					var move = body.getArea() as Circle2d + influence.getMove() 
					this.rootTree.moveBody(body, new Point2d(move.getX(), move.getY()))
					
				} else if (action == Action.arrest) {
					
				} else if (action == Action.destroy) {
					
				} else if (action == Action.despawn){
					
				} else if (action == Action.smoke){
					//nothing for now
				} else if (action == Action.changeBeh){
					
				}
	
			}
			
			//if all destoyables gone stop simu crs lose
			// else continue turning until there are still protestors
			redraw()
			this.influenceList.clear()
//			if(this.time++ <100){
//				
//				//trouver un wait meilleur
//			
//			}
			StartSim()
		}
			
	}
	
	def resolveInfluences(influences : ArrayList<Influence>){//j'ai mal
		for(influence : influences){
			var action : Action = influence.getAction()
			if(action == Action.move){
				
			}
			else if(action == Action.arrest){
				
			}
			else if(action == Action.destroy){
				
			}
		}
	}

	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent environment was stopped.")
	}
	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on SpaceCreated {
		// Event trigger when a space is created into one of the contexts where the agent is.
	}

	on SpaceDestroyed {
		// Event trigger when a space is destroyed from one of the contexts where the agent is.
	}

	on ParticipantJoined {
		// Event trigger when a participant has joined a space.
	}

	on ParticipantLeft {
		// Event trigger when a participant has left a space.
	}
}
