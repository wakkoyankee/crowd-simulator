/** 
 * 
 */
package crs_sim.environment

import crs_sim.body.EnvObject
import crs_sim.body.MobileObject
import crs_sim.utils.CRS_Sim_Utils
import crs_sim.utils.ParamSimu
import java.util.ArrayList
import java.util.Collection
import java.util.List
import org.arakhne.afc.math.geometry.d2.d.Circle2d
import org.arakhne.afc.math.geometry.d2.d.Point2d
import org.arakhne.afc.math.geometry.d2.d.Rectangle2d
import org.arakhne.afc.math.tree.node.QuadTreeNode
import org.eclipse.xtend.lib.annotations.Accessors

/** 
 * @author Thomas
 * 
 */
class QTNode extends QuadTreeNode<EnvObject, QTNode> {

		@Accessors(PUBLIC_GETTER)
		val area : Rectangle2d
		
		new (area : Rectangle2d) {
			super();
			this.area = area
		}

		/** Construct a node.
	 * @param data are the initial user data
	 */
		new (collec : Collection<EnvObject>, area : Rectangle2d) {
			super(collec)
			this.area = area
		}
		
		def insert(object :EnvObject) : void{			
			
			if ((CRS_Sim_Utils.AinB(object.area, area)) 
				&& (getUserDataCount() < ParamSimu.maxObjectsPerChild)) {
				addUserData(object) 		// ajouter dans l'object courant
			} else if (CRS_Sim_Utils.AinB(object.area, area) 
				&& getUserDataCount() >= ParamSimu.maxObjectsPerChild) {
					
				if(getNotNullChildCount()<=0 /*je n ai pas d enfants getFirstChild() == null?*/){
					 initChilds()
					 //essayer de dispatcher les éléments dans les fils
				}
				switch (CRS_Sim_Utils.childFit(object.area,area)){
					case 0:
						//fit nowhere
						addUserData(object)
					case 1:
						firstChild.insert(object)
					case 2:
						secondChild.insert(object)					
					case 3:
						thirdChild.insert(object)
					case 4:
						fourthChild.insert(object)
				}
			} else {
				// does not fit un current node
				getParentNode().insert(object)
			}			
		}
		
		def initChilds() {
			var rect = new Rectangle2d()
			if(firstChild != null && secondChild != null &&
				thirdChild != null && fourthChild != null
			) return false
			else{
				// NW				
				setFirstChild(new QTNode(
					new Rectangle2d(area.getMinX, area.getMinY, area.getMaxX / 2, area.getMaxY / 2)
				))
						
				// NE
				setSecondChild(new QTNode(
					new Rectangle2d(area.getMaxX / 2, area.getMinY, area.getMaxX/2, area.getMaxY / 2)
				))
				
				// SW
				setThirdChild(new QTNode(
					new Rectangle2d(area.getMinX, area.getMaxY/2, area.getMaxX/2, area.getMaxY/2)
				))
				
				// SE
				setFourthChild(	new QTNode(
					new Rectangle2d(area.getMaxX / 2, area.getMaxY / 2, area.getMaxX/2, area.getMaxY/2)
				))
				
				return true
			}
		}

	def getBodies() : List<Percept> {
		var objects = getAllUserData
		var result : List<Percept> = new ArrayList<Percept>
		for (object : objects) {
				result.add(new Percept(
					object.area,
					object.uuid,
					object.type
				))						
		}
		return result.toList
	}

	def getPercept(perception : Circle2d): List<Percept> {
		var objects = getAllUserData
		var result : List<Percept> = new ArrayList<Percept>
		for (object : objects){
			if (perception.intersects(object.area))
				result.add(new Percept(
					object.area,
					object.uuid,
					object.type // ça va changer
				))					
		}
		return result.toList
	}
	
	// should be called by the source node (otherwise we may can't find the object)
	def moveBody(body: MobileObject, point: Point2d): void{
		//the body your looking for is in this node
		if (allUserData.contains(body)) {
			// do we try to move out of the map ?
			if (point.x > ParamSimu.mapSizeX || point.x < ParamSimu.mapSizeX || point.y > ParamSimu.mapSizeY ||
				point.y < ParamSimu.mapSizeY){
					println("Il faut supprimer l'élément (pas encore implémenté potentiellement a sup)")
			}
			//body remain in this node after changing his position
			if (CRS_Sim_Utils.AinB(point, area))
				body.setArea(point)
			//body will be in an other node
			else {
				removeUserData(body)
				body.setArea(point)
				insert(body)
			}
		} else {
			print("Le résultat de childFit est : " +
				CRS_Sim_Utils.childFit(body.position, area) + "\n")
			// searching in which child the body is
			try {
				switch (CRS_Sim_Utils.childFit(body.position,area)) {
					case 0:
						if (point.x > ParamSimu.mapSizeX || point.x < ParamSimu.mapSizeX
							|| point.y > ParamSimu.mapSizeY || point.y < ParamSimu.mapSizeY	){
								println("Body should be deleted
									__body : " + body.type + " Position : " + body.position)
							} else {
								println("buddy your body is lost.. RIP
								__body : " + body.type + " Position : " + body.position)
							}
						
					case 1:
						firstChild.moveBody(body, point)
					case 2:
						secondChild.moveBody(body, point)
					case 3:
						thirdChild.moveBody(body, point)
					case 4:
						fourthChild.moveBody(body, point)
				}
			} catch (e : Exception) {
				print("Erreur de déplacement d'enfant \nLe résultat de childFit est : " +
					CRS_Sim_Utils.childFit(body.position, area) + 
					"body : " + body.type + " Position : " + body.position +"\n")
				
			}
		}
	}

	
	def deleteBody(body : EnvObject, save : List<EnvObject>) : void {
		// the body your looking for is in this node
		if (allUserData.contains(body)) {
			save.add(body)//__________________serait cool de save d'autres infos genre date d'arrivée etc
			removeUserData(body)
		} else {
			// searching in which child the body is
			switch (CRS_Sim_Utils.childFit(body.position,area)) {
				case 0:
					print("buddy your body is lost.. RIP")
				case 1:
					firstChild.deleteBody(body, save)
				case 2:
					secondChild.deleteBody(body, save)
				case 3:
					thirdChild.deleteBody(body, save)
				case 4:
					fourthChild.deleteBody(body, save)
			}
		}
	}
}
