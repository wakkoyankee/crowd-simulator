/** 
 * 
 */
package crs_sim.^agent

import crs_sim.environment.Percept
import crs_sim.utils.ParamSimu
import crs_sim.utils.Types
import io.sarl.core.Logging
import java.util.ArrayList
import org.arakhne.afc.math.geometry.d2.d.Circle2d
import org.arakhne.afc.math.geometry.d2.d.Point2d
import org.arakhne.afc.math.geometry.d2.d.Rectangle2d
import org.arakhne.afc.math.geometry.d2.d.Vector2d

/** 
 * @author hadrien
 * 
 */
skill MovementSkill implements MovementCapacity {
	uses Logging

	def install {
		// Function invoked when the skill is installed in the owner.
		// You should put all the initialization statements in this block of code.
		//info("Installing the skill")
	}

	def prepareUninstallation {
		// Function invoked when the skill is preparing to be uninstalled from the owner, but before the owner is destroyed.
		// You should put all the resource release statements that should be executed before the owner is destroyed.
		//info("Preparing the uninstallation of the skill")
	}

	def uninstall {
		// Function invoked when the skill is uninstalled from the owner, and after the owner is destroyed.
		// You should put all the resource release statements in this block of code.
		//info("Uninstalling the skill")
	}
	
	def distance_vector(V : Vector2d) {
		return Math.sqrt(V.getX() ** 2 + V.getY() ** 2)
	}
	
	def percent_distance_vector(V : Vector2d, T : int) : double{
//		println('% dist = ' + Math.sqrt(V.getX() ** 2 + V.getY() ** 2) / T)
//		println('dist = ' + Math.sqrt(V.getX() ** 2 + V.getY() ** 2) )
//		println('T = ' +  T)
		return Math.sqrt(V.getX() ** 2 + V.getY() ** 2) / T
	}
	
	def normalize_vector(V : Vector2d, T : int){
		V.setX(V.getX() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / T))
		V.setY(V.getY() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / T))
		return V
	}
	
	def normal_building(R : Rectangle2d, P : Circle2d, V : Vector2d){
		if (P.getX() == R.getMaxX){
			if (V.getX() < 0){
				V.setX(0)
			}
		}
		else if (P.getX() == P.getMinX){
			if (V.getX() > 0){
				V.setX(0)
			}
		}
		if (P.getY() == R.getMaxY){
			if (V.getY() < 0){
				V.setY(0)
			}
		}
		else if (P.getY() == P.getMinY){
			if (V.getY() > 0){
				V.setY(0)
			}
		}
	}
	
	def colision_building(R : Rectangle2d, P : Circle2d, V : Vector2d){
		var C = new Point2d(P.getX() + V.getX(), P.getY() + V.getY())
		println('colision C x = ' + C.getX())
		println('colision C y = ' + C.getY())
		println('colision P x = ' + P.getX())
		println('colision P y = ' + P.getY())
		if (C.getX <= R.getMaxX && C.getX() >= R.getMinX && C.getY() <= R.getMaxY && C.getY() >= R.getMinY){
			println('colision Vb x = ' + V.getX())
			println('colision Vb y = ' + V.getY())
			if (P.getX() >= R.getMaxX){
				V.setX(V.getX()*(Math.abs(R.getMaxX() - P.getX()) / V.getX()))
				V.setY(V.getY()*(Math.abs(R.getMaxX() - P.getX()) / V.getX()))
				println('colision x = ' + V.getX())
				println('colision y = ' + V.getY())
			}
			else if (P.getX() <= R.getMinX){
				V.setX(V.getX()*(Math.abs(R.getMinX() - P.getX()) / V.getX()))
				V.setY(V.getY()*(Math.abs(R.getMinX() - P.getX()) / V.getX()))
				println('colision x = ' + V.getX())
				println('colision y = ' + V.getY())
			}
			else if (P.getY() >= R.getMaxY){
				V.setX(V.getX()*(Math.abs(R.getMaxY() - P.getY()) / V.getY()))
				V.setY(V.getY()*(Math.abs(R.getMaxY() - P.getY()) / V.getY()))
				println('colision x = ' + V.getX())
				println('colision y = ' + V.getY())
			}
			else if (P.getY() <= R.getMinY){
				V.setX(V.getX()*(Math.abs(R.getMinY() - P.getY()) / V.getY()))
				V.setY(V.getY()*(Math.abs(R.getMinY() - P.getY()) / V.getY()))
				println('colision x = ' + V.getX())
				println('colision y = ' + V.getY())
			}
		}
		
	}

	override influenceKinematic(position : Circle2d, ListOfTarget : ArrayList<Percept>, obj : Rectangle2d) : Vector2d {
		var v = new Vector2d(obj.getMinX() - position.getX(), obj.getMinY() - position.getY());
//		println('objectif x = ' + obj.getMinX())
//		println('objectif y = ' + obj.getMinY())
		v.setX(v.getX() / ((Math.abs(v.getX()) + Math.abs(v.getY())) / ParamSimu.TargetForce))
		v.setY(v.getY() / ((Math.abs(v.getX()) + Math.abs(v.getY())) / ParamSimu.TargetForce))
		//println('tX = ' + v.getX())
		//println('tY = ' + v.getY())
		
		for (target : ListOfTarget) {
		//println('position = ' + position.getX())
		//println('position = ' + position.getY())
			if (target.getName() == Types.protestor_panic){
				var shape : Circle2d = target.getShape() as Circle2d
				var V : Vector2d = new Vector2d(position.getX() - shape.getX(), position.getY() - shape.getY())
				var P : double = (1 - percent_distance_vector(V, ParamSimu.RadiusPerceptProtestor))
				//print()
				//println('p.X = ' + v.getX())
				//print()
				//println('p.Y = ' + v.getY())
				if (position.getX() == shape.getX() && position.getY() == shape.getY()){
					V.setX(0)
					V.setY(0)
				}
				else {
				V.setX(V.getX() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.PanicForce))
				V.setY(V.getY() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.PanicForce))
				//println('p..X = ' + v.getX())
				//println('p..Y = ' + v.getY())
				v.setX((V.getX() * P) + v.getX())
				v.setY((V.getY() * P) + v.getY())
				
				//println('pX = ' + v.getX())
				//println('pY = ' + v.getY())
				}
			}
			if (target.getName() == Types.protestor_neutral) {
				var shape : Circle2d = target.getShape() as Circle2d
				var V : Vector2d = new Vector2d(position.getX() - shape.getX(), position.getY() - shape.getY())
				var P : double = (1 - percent_distance_vector(V, ParamSimu.RadiusPerceptProtestor))
				//print('target = ')
				//println(shape.getX())
				//print('target = ')
				//println(shape.getY())				
				if (position.getX() == shape.getX() && position.getY() == shape.getY()){
					V.setX(0)
					V.setY(0)
				}
				else {
				V.setX(V.getX() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.NeutralForce))
				V.setY(V.getY() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.NeutralForce))
				v.setX((V.getX() * P) + v.getX())
				v.setY((V.getY() * P) + v.getY())
				//println('n.X = ' + v.getX())
				//println('n.Y = ' + v.getY())
				//println('n..X = ' + v.getX())
				//println('n..Y = ' + v.getY())
				//println('nX = ' + v.getX())
				//println('nY = ' + v.getY())
				
				}
			}
			if (target.getName() == Types.protestor_agg) {
				var shape : Circle2d = target.getShape() as Circle2d
				var V : Vector2d = new Vector2d(position.getX() - shape.getX(), position.getY() - shape.getY())
				var P : double = (1 - percent_distance_vector(V, ParamSimu.RadiusPerceptProtestor))
				if (position.getX() == shape.getX() && position.getY() == shape.getY()){
					V.setX(0)
					V.setY(0)
				}
				else {
				V.setX(V.getX() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.AgressiveForce))
				V.setY(V.getY() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.AgressiveForce))
				v.setX((V.getX() * P) + v.getX())
				v.setY((V.getY() * P) + v.getY())
				//print('aX = ')
				//println(v.getX())
				//print('aY = ')
				//println(v.getY())
				}
			}
			if (target.getName() == Types.building) {
				var shape : Rectangle2d = target.getShape() as Rectangle2d
				//println('hey !')
				if (position.getX() < shape.getMinX()) {
					if (position.getY() < shape.getMinY()) { // pointe sud ouest du rectangle
						var V : Vector2d = new Vector2d(position.getX() - shape.getMinX(), position.getY() - shape.getMinY())
//						println('minminX position = ' + position.getX())
//						println('minminY position = ' + position.getY())
//						println('minminX shape = ' + shape.getMinX())
//						println('minminY shape = ' + shape.getMinY())
					 	var P : double = (1 - percent_distance_vector(V, ParamSimu.RadiusPerceptProtestor))
//						println('minminX = ' + V.getX())
//						println('minminY = ' + V.getY())
						V.setX(V.getX() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.BuildingForce))
						V.setY(V.getY() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.BuildingForce))
						v.setX((V.getX() * P) + v.getX())
						v.setY((V.getY() * P) + v.getY())
						//print('b1X = ')
						//println(v.getX())
						//print('b1Y = ')
						//println(v.getY())
		}
					else if (position.getY() > shape.getMaxY()) { // pointe nord ouest du rectangle
						var V : Vector2d = new Vector2d(position.getX() - shape.getMinX(), position.getY() - shape.getMaxY())
					 	var P : double = (1 - percent_distance_vector(V, ParamSimu.RadiusPerceptProtestor))
//						println('minminX = ' + V.getX())
//						println('minmaxY = ' + V.getY())
						V.setX(V.getX() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.BuildingForce))
						V.setY(V.getY() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.BuildingForce))
						v.setX((V.getX() * P) + v.getX())
						v.setY((V.getY() * P) + v.getY())
					}
					else { // cote ouest du rectangle
						var V : Vector2d = new Vector2d(position.getX() - shape.getMinX(), 0)
					 	var P : double = (1 - percent_distance_vector(V, ParamSimu.RadiusPerceptProtestor))
//						println('min0X = ' + V.getX())
						V.setX(V.getX() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.BuildingForce))
						v.setX((V.getX() * P) + v.getX())
						
					}
				}
				else if (position.getX() > shape.getMaxX()) {
					if (position.getY() < shape.getMinY()) { // pointe sud est du rectangle
						var V : Vector2d = new Vector2d(position.getX() - shape.getMaxX(), position.getY() - shape.getMinY())
					 	var P : double = (1 - percent_distance_vector(V, ParamSimu.RadiusPerceptProtestor))
//						println('maxminX = ' + V.getX())
//						println('maxminY = ' + V.getY())
						V.setX(V.getX() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.BuildingForce))
						V.setY(V.getY() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.BuildingForce))
						v.setX((V.getX() * P) + v.getX())
						v.setY((V.getY() * P) + v.getY())
						}
					 else if (position.getY() > shape.getMaxY()) { // pointe nord est du rectangle
						var V : Vector2d = new Vector2d(position.getX() - shape.getMaxX(), position.getY() - shape.getMaxY())
					 	var P : double = (1 - percent_distance_vector(V, ParamSimu.RadiusPerceptProtestor))
//						println('maxmaxX = ' + V.getX())
//						println('maxmaxY = ' + V.getY())
						V.setX(V.getX() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.BuildingForce))
						V.setY(V.getY() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.BuildingForce))
						v.setX((V.getX() * P) + v.getX())
						v.setY((V.getY() * P) + v.getY())
						}
					 else { // cote est du rectangle
						var V : Vector2d = new Vector2d(position.getX() - shape.getMaxX(), 0)
					 	var P : double = (1 - percent_distance_vector(V, ParamSimu.RadiusPerceptProtestor))
//						println('max0X = ' + V.getX())
						V.setX(V.getX() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.BuildingForce))
						v.setX((V.getX() * P) + v.getX())
					}
				}
				else {
					if (position.getY() < shape.getMinY()) { // cote sud du rectangle
						var V : Vector2d = new Vector2d(0, position.getY() - shape.getMinY())
					 	var P : double = (1 - percent_distance_vector(V, ParamSimu.RadiusPerceptProtestor))
//						println('0minY = ' + V.getY())
						V.setY(V.getY() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.BuildingForce))
						v.setY((V.getY() * P) + v.getY())
					}
					else { // cote nord du rectangle
						var V : Vector2d = new Vector2d(0, position.getY() - shape.getMaxY())
					 	var P : double = (1 - percent_distance_vector(V, ParamSimu.RadiusPerceptProtestor))
//						println('0maxY = ' + V.getY())
						V.setY(V.getY() / ((Math.abs(V.getX()) + Math.abs(V.getY())) / ParamSimu.BuildingForce))
						v.setY((V.getY() * P) + v.getY())
					}
				}	
			}
		}
		v.setX(v.getX() / ((Math.abs(v.getX()) + Math.abs(v.getY())) / ParamSimu.Speed))
		v.setY(v.getY() / ((Math.abs(v.getX()) + Math.abs(v.getY())) / ParamSimu.Speed))
		
		//println('X. = ' + v.getX())
		//println('Y. = ' + v.getY())
		v.setX(v.getX() / ((Math.abs(v.getX()) + Math.abs(v.getY())) / ParamSimu.Speed))
		v.setY(v.getY() / ((Math.abs(v.getX()) + Math.abs(v.getY())) / ParamSimu.Speed))
		//print('X = ')
		//println(v.getX())
		//print('Y = ')
		//println(v.getY())
		
		for (target : ListOfTarget) {
			if (target.getName() == Types.building) {
				var shape : Rectangle2d = target.getShape() as Rectangle2d
				colision_building(shape, position, v)
				//normal_building(shape, position, v)
//				if (CRS_Sim_Utils.AinB(position.center, shape)){
//					if ()
//				}
			}
		}
		
		
		
		return v;
		
	}
}