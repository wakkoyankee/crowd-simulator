/** 
 * 
 */
package crs_sim.^agent

import crs_sim.environment.Influence
import crs_sim.environment.InfluenceEvent
import crs_sim.environment.Percept
import crs_sim.environment.PerceptionEvent
import crs_sim.utils.Action
import crs_sim.utils.ParamSimu
import crs_sim.utils.Types
import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.ParticipantJoined
import io.sarl.core.ParticipantLeft
import io.sarl.core.SpaceCreated
import io.sarl.core.SpaceDestroyed
import java.util.ArrayList
import org.arakhne.afc.math.geometry.d2.d.Circle2d
import org.arakhne.afc.math.geometry.d2.d.Rectangle2d
import org.arakhne.afc.math.geometry.d2.d.Vector2d

/** 
 * @author hadrien
 * 
 */
behavior Neutral {
	uses Logging
	uses DefaultContextInteractions
	
	var memory : Memory
	var moveS : MovementSkill
	
	new (owner : Protestor, memory : Memory) {
		super(owner)
		this.memory = memory
	}
	
	on Initialize {
		//info("Neutral behavior was started.")
		this.moveS = new MovementSkill
		setSkill(this.moveS)
	}

	on Destroy {
		// Event trigger when the behavior is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("Neutral behavior was stopped.")
	}

	on PerceptionEvent {
		//info("Neutral hello")
		var obj = occurrence.obj as Rectangle2d
		var body = occurrence.body as Circle2d
		var perceptions = occurrence.perceptions as ArrayList
		
		if (body.intersects(obj)) { // atteint l'objectif
			var inf = new Influence(owner.getID(), Action.despawn)
			emit(new InfluenceEvent(inf))[it.UUID == occurrence.source.UUID]
			////////////////////////////////////////////////////////////////////
			//despawn
			return
		}
		
		// Peut etre l'appell√© tout les temps t sinon un peu lourd
		var beh = CalculateBeh(perceptions)
		
		if (beh == null) {//no behavior change
			var move : Vector2d = this.moveS.influenceKinematic(body, perceptions, obj)
			var inf = new Influence(owner.getID(), Action.move, move)
			emit(new InfluenceEvent(inf))[it.UUID == occurrence.source.UUID]
		}
		else {//behavior change
			var inf = new Influence(owner.getID(), Action.changeBeh, beh)
			emit(new InfluenceEvent(inf))[it.UUID == occurrence.source.UUID]
			Behaviourchange(beh)
		}
		
	}

	def CalculateBeh(perceptions : ArrayList<Percept>) {
		var numP = 0
		var numA = 0
		var numN = 0
		var numC = 0
		for (percept : perceptions) {
			switch percept.getName() {
				case Types.protestor_panic: numP++
				case Types.protestor_agg: numA++
				case Types.protestor_neutral: numN++
				case Types.crs: numC++
			}
		}
		// //behavior calculation
		// this.memory.setBehavior()
		var b = this.memory.getBehavior()
		if (b < ParamSimu.maxPanic) {
			return Types.protestor_panic
		}
		else if (b > ParamSimu.minAggressive) {
				return Types.protestor_agg
		
		}
		else {
			return null
		}
	}

	def Behaviourchange(newbeh : Types) {
		var o = owner as Protestor
		o.changeBehavior(newbeh)
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a behavior of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a behavior of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on SpaceCreated {
		// Event trigger when a space is created into one of the contexts where the agent is.
	}

	on SpaceDestroyed {
		// Event trigger when a space is destroyed from one of the contexts where the agent is.
	}

	on ParticipantJoined {
		// Event trigger when a participant has joined a space.
	}

	on ParticipantLeft {
		// Event trigger when a participant has left a space.
	}
}
